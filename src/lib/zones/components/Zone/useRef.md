# Очевидные нарушения

Для начала стоит освежить в памяти, что [про useRef говорит документация React](https://react.dev/reference/react/useRef)

После чтения документации сразу становится понятно, что useRef в **[UseRefZone.tsx](./UseRefZone.tsx)** используется с нарушением предостережения:

```
Do not write or read ref.current during rendering.
```

Очевидно, что установка значения для current

```
context.current = { n };
```

и последующая передача этого ref в компонент

```
<ZoneContext.Provider value={context}>
```

осуществляется во время рендеринга компонента.

**При использовании useRef надо следовать рекомендации:**

```
You can read or write refs from event handlers or effects instead.
```

> **Для меня уже этого достаточно, чтобы так не делать.**

# Ререндеры компонентов

_см. страницу /zones_

[В документации к memo говорится](https://react.dev/reference/react/memo), что

```
React normally re-renders a component whenever its parent re-renders.
```

Т.е.

- если перерисовывается родительский компонент, то всякий раз будут перерисовываться и child-ы. Чтобы предотвратить перерисовку child-ов без изменения их props-ов надо обернуть их в memo.

- если предполагалось, что useRef будет предотвращать лишние перерисовки child-ов, то это 100% не так без использования memo или useMemo.

> **Т.е. если компонент не мемоизирован, то и useRef ни на что не повлияет**

# Проверка разных комбинаций

- Зона без useRef, child не зависит от контектса зоны

  - child без memo

    Изменяем props-ы зоны. Зона и child ререндерится.

  - child с memo

    Изменяем props-ы зоны. Зона ререндерится, а child - нет.

---

- Зона без useRef, child зависит от контекста зоны

  - memo и useMemo для child не имеет значения

    Изменяем props-ы зоны. Зона и child ререндерятся.

---

- Зона c useRef, child не зависит от контектса зоны

  - child без memo

    Изменяем props-ы зоны. Зона и child ререндерятся.

  - child с memo

    Изменяем props-ы зоны. Зона ререндерится, а child - нет.

  - **Поведение одинаковое изменяется current в процессе рендеринга или нет**

---

- Зона c useRef, child зависит от контектса зоны

  - child без memo

    Изменяем props-ы зоны. Зона и child ререндерится.

    > Здесь если убрать изменение current в процессе рендеринга, то child перестанет получать актуальные данные контекста, но при этом будет ререндериться

  - child с memo

    Изменяем props-ы зоны. Зона ререндерится, **а child - нет**

    **но и значение контекста не меняется**

    > Т.е. вот существенное отличие от варианта без useRef.
    >
    > Если child зависит от контекста, зона без useRef, то memo ни на что не влияет - child все равно ререндерится вместе с изменением контекста **и child получает актуальные данные контекста**
    >
    > Если же мы добавляем useRef, то использование memo предотвращает ререндер child-а, который зависит от контекста. **Но и child не получает актуальные данные контекста.**

    > В этой случае не важно меняется current во время рендеринга или нет - поведение одинаковое

# Выводы

- useRef без memo точно не имеет никакого смысла

- useRef с memo может предотвратить rerender-ы
  - Но это может как оптимизировать приложение
  - Точно также это может привести к багам, т.к. child не получит актуальное состояние контекста или не будет обновления current в процессе рендеринга и тогда сломается вариант без memo (перерисовки будут, а получение актуального контекста - нет)

Гипотетически это может быть полезно, но я считаю, что более высока вероятность получить забагованную лживую аналитику.

Таким образом, использование useRef может быть оправдано если

- приложение сложное, с большим количеством компонентов, сложной логикой или частыми перерисовками
- в приложении часто и **оправданно** используется мемоизация

> Но это надо делать ооочень аккуратно
>
> - с полным пониманием зачем оно нужно
> - c чательной проверкой функциональности
>   - в часности аналитики мемоизированных компонент
> - написанием тестов, которые будут гарантировать, что функциональность работает ожидаемо

**Во всех остальных случаях лучше так не делать.**
